<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.520">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="신록예찬">
<meta name="dcterms.date" content="2025-02-12">

<title>신록예찬’s Blog - 2.1 – Basic Theory</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
</head>

<body>

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul class="collapse">
  <li><a href="#ref" id="toc-ref" class="nav-link active" data-scroll-target="#ref"><span class="header-section-number">0.1</span> ref</a></li>
  <li><a href="#stochastic-convergence" id="toc-stochastic-convergence" class="nav-link" data-scroll-target="#stochastic-convergence"><span class="header-section-number">1</span> Stochastic Convergence</a>
  <ul class="collapse">
  <li><a href="#basic-theory" id="toc-basic-theory" class="nav-link" data-scroll-target="#basic-theory"><span class="header-section-number">1.1</span> Basic Theory</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">1.2</span> References</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">2.1 – Basic Theory</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>신록예찬 </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 12, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="ref" class="level2" data-number="0.1">
<h2 data-number="0.1" class="anchored" data-anchor-id="ref"><span class="header-section-number">0.1</span> ref</h2>
<blockquote class="blockquote">
<p><span class="citation" data-cites="van2000asymptotic">@van2000asymptotic</span></p>
</blockquote>
</section>
<section id="stochastic-convergence" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Stochastic Convergence</h1>
<section id="basic-theory" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="basic-theory"><span class="header-section-number">1.1</span> Basic Theory</h2>
<p><code>-</code> 랜덤 벡터 <span class="math inline">\(X\)</span>는 <span class="math inline">\(\mathbb{R}^k\)</span>에서 정의된 실수 랜덤 변수들의 벡터로, 분포 함수(distribution function)는 <span class="math inline">\(x \mapsto P(X \leq x)\)</span>로 표현된다.</p>
<p><code>-</code> 랜덤 벡터 <span class="math inline">\(X_n\)</span>이 <span class="math inline">\(X\)</span>에 대해 분포 수렴(convergence in distribution)한다고 할 때, 이는 모든 연속점 <span class="math inline">\(x\)</span>에서 다음이 성립함을 의미한다. <span class="math display">\[
P(X_n \leq x) \to P(X \leq x).
\]</span> 이러한 수렴은 약수렴(weak convergence) 또는 법칙 수렴(convergence in law)이라고도 하며, 확률 공간 자체가 아니라 확률 분포에 의존하는 성질이다. 표기법으로는 <span class="math inline">\(X_n \Rightarrow X\)</span>를 사용하며, 만약 <span class="math inline">\(X\)</span>가 특정한 분포 <span class="math inline">\(L\)</span>을 따른다면 <span class="math inline">\(X_n \Rightarrow L\)</span>로 표현한다. 예를 들어, <span class="math inline">\(X_n\)</span>이 표준 정규분포를 따른다면 <span class="math inline">\(X_n \Rightarrow N(0,1)\)</span>로 나타낼 수 있다.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong><em>분포수렴에서 연속조건~</em></strong></p>
<p>분포 수렴(convergence in distribution)은 확률 변수 <span class="math inline">\(X_n\)</span>의 누적분포함수(CDF) <span class="math inline">\(F_n(x)\)</span>가 <span class="math inline">\(X\)</span>의 누적분포함수 <span class="math inline">\(F(x)\)</span>로 수렴하는 것을 의미한다. 즉, <span class="math display">\[
P(X_n \leq x) \to P(X \leq x)
\]</span> 가 성립해야 한다. 하지만, 이 수렴이 모든 <span class="math inline">\(x\)</span>에서 성립해야 하는 것은 아니며, <span class="math inline">\(F(x)\)</span>가 연속인 점에서만 보장되면 충분하다.</p>
<p>이러한 조건이 필요한 이유는 누적분포함수는 불연속점을 가질 수 있기 때문이다. 특히, 이산형 확률 변수의 경우 특정한 점에서 점프가 발생하는데, 분포 수렴은 이러한 점프의 크기나 위치에는 민감하지 않다. 따라서, 연속점에서만 수렴을 요구하는 것이 합리적이며, 이는 확률 분포가 전반적으로 변하지 않는다는 의미에서 충분한 조건이 된다. 이러한 수렴 조건은 스크로호드 정리(Skorokhod’s Representation Theorem)를 통해 더욱 직관적으로 해석될 수 있다. 이 정리에 따르면, 분포 수렴이 이루어진다면 동일한 확률 공간에서 정의된 확률 변수 <span class="math inline">\(\tilde{X}_n\)</span>과 <span class="math inline">\(\tilde{X}\)</span>를 구성할 수 있으며, 이 변수들은 동일한 분포를 가지면서도 거의 확실하게(almost surely) 수렴하는 성질을 가진다. 결론적으로, 분포 수렴에서 “모든 점”이 아니라 “모든 연속점에서” 수렴을 요구하는 것은 수학적으로 자연스럽고 실용적인 정의이다.</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><strong><em>분포수렴은 확률공간에 의존하지 않아~</em></strong></p>
<p>분포 수렴(convergence in distribution)은 법칙 수렴(convergence in law)이라고도 하며, 이는 확률 변수의 개별적인 값이 아니라 확률 분포 자체가 수렴하는 개념이다. 즉, 확률 공간 <span class="math inline">\((\Omega, \mathcal{F}, P)\)</span> 위에서 정의된 확률 변수 <span class="math inline">\(X_n\)</span>이 확률 변수 <span class="math inline">\(X\)</span>로 분포 수렴한다는 것은 다음을 의미한다.</p>
<p><span class="math display">\[
P(X_n \leq x) \to P(X \leq x) \quad \text{for all continuity points of } F(x).
\]</span></p>
<p>이때 중요한 점은 확률 공간 자체가 아니라 확률 분포에 의존하는 성질이라는 점이다. 즉, <span class="math inline">\(X_n\)</span>과 <span class="math inline">\(X\)</span>가 정의된 확률 공간이 무엇이든 간에, 그들이 동일한 확률 분포를 갖는다면 분포 수렴의 여부는 변하지 않는다. 예를 들어, 서로 다른 확률 공간에서 정의된 확률 변수 <span class="math inline">\(X_n\)</span>과 <span class="math inline">\(Y_n\)</span>이 존재한다고 하자. 만약 이들이 같은 분포를 가진다면, 즉 <span class="math display">\[
X_n \overset{d}{=} Y_n, \quad \forall n,
\]</span> 이고, <span class="math inline">\(X_n\)</span>이 <span class="math inline">\(X\)</span>로 분포 수렴한다면, <span class="math inline">\(Y_n\)</span>도 동일하게 <span class="math inline">\(X\)</span>로 분포 수렴하게 된다. 다시 말해, 분포 수렴은 확률 공간을 넘어서 동일한 분포를 가지는 모든 확률 변수에 대해 성립하는 성질이며, 확률 공간에 따라 달라지는 개별적인 사건(realization)에는 영향을 받지 않는다.</p>
</div>
</div>
<p><code>-</code> 다음으로, 거리 함수(distance function) <span class="math inline">\(d(x,y)\)</span>는 <span class="math inline">\(\mathbb{R}^k\)</span>에서 일반적인 위상을 정의하는 역할을 한다. 특히, 유클리드 거리(Euclidean distance)는 다음과 같이 정의된다. <span class="math display">\[
d(x, y) = \| x - y \| = \left( \sum_{i=1}^{k} (x_i - y_i)^2 \right)^{1/2}.
\]</span></p>
<p>랜덤 변수 <span class="math inline">\(X_n\)</span>이 <span class="math inline">\(X\)</span>에 대해 확률 수렴(convergence in probability)한다고 할 때, 이는 모든 <span class="math inline">\(\varepsilon &gt; 0\)</span>에 대해 다음이 성립함을 의미한다. <span class="math display">\[
P(d(X_n, X) &gt; \varepsilon) \to 0.
\]</span> 확률 수렴은 <span class="math inline">\(X_n \xrightarrow{P} X\)</span>로 표기하며, <span class="math inline">\(d(X_n, X) \xrightarrow{P} 0\)</span>과 같은 의미로 해석할 수 있다.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p><span class="math inline">\(k=1\)</span> 이면 <span class="math inline">\(d(x,y)=\sqrt{(x-y)^2}=|x-y|\)</span> 이다.</p>
</div>
</div>
<p>:::{.callout-note}</p>
<p><strong><em>Skorokhod’s Representation Theorem.</em></strong></p>
<p>확률 변수의 수열 <span class="math inline">\(X_n\)</span>이 <span class="math inline">\(X\)</span>로 분포 수렴한다고 가정하자. 즉, <span class="math display">\[
X_n \Rightarrow X.
\]</span> 그러면, 동일한 확률 분포를 가지는 새로운 확률 변수 <span class="math inline">\(\tilde{X}_n, \tilde{X}\)</span>를 구성할 수 있으며, 이들은 동일한 확률 공간 <span class="math inline">\((\Omega, \mathcal{F}, P)\)</span> 위에서 정의되면서 거의 확실하게(almost surely) 수렴하는 성질을 갖는다. 즉, <span class="math display">\[
\tilde{X}_n \to \tilde{X} \quad \text{almost surely}.
\]</span> 여기서 <span class="math inline">\(\tilde{X}_n\)</span>과 <span class="math inline">\(\tilde{X}\)</span>는 각각 원래의 <span class="math inline">\(X_n\)</span>과 <span class="math inline">\(X\)</span>와 동일한 분포를 가지며, 이 새로운 확률 변수들은 동일한 확률 공간에서 정의되었기 때문에 거의 확실한 수렴을 논의할 수 있다.</p>
</section>
<section id="references" class="level2" data-number="1.2">
<h2 data-number="1.2" class="anchored" data-anchor-id="references"><span class="header-section-number">1.2</span> References</h2>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    const typesetMath = (el) => {
      if (window.MathJax) {
        // MathJax Typeset
        window.MathJax.typeset([el]);
      } else if (window.katex) {
        // KaTeX Render
        var mathElements = el.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
          var texText = mathElements[i].firstChild;
          if (mathElements[i].tagName == "SPAN") {
            window.katex.render(texText.data, mathElements[i], {
              displayMode: mathElements[i].classList.contains('display'),
              throwOnError: false,
              macros: macros,
              fleqn: false
            });
          }
        }
      }
    }
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        typesetMath(container);
        return container.innerHTML
      } else {
        typesetMath(note);
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      typesetMath(note);
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>